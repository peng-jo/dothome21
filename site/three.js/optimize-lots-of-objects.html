<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>population</title>
  <style>
    canvas {
      max-width: calc(100% - 16px);
    }
  </style>
</head>
<body>
<canvas>

</canvas>
</body>
<script type="module">
import * as THREE from  '../../assets/js/three.module.js';
const canvas = document.querySelector('canvas');
function main(){

  //WebGLRenderer 생성
  /*
    렌더러 :
    (renderer)는 여러분이 입력한 데이터를
    실제로 canvas에 그려주는 역할을 맡습니다. 
  */
const renderer = new THREE.WebGLRenderer({canvas});
// the canvas default
const fov = 75;
const aspect = canvas.clientWidth / canvas.clientHeight; 
const near = 0.1;
const far = 5;

//카메라 생성
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
camera.position.z = 2;

const resizeRendererToDisplaySize = (renderer)=> {
  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}
/* 씬 생성 */
const scene = new THREE.Scene();


async function loadFile(url) {
  const req = await fetch(url);
  return req.text();
}
function addBoxes(file) {
  const { min, max, data } = file;
  const range = max - min;

  // 육면체 geometry를 만듭니다.
  const boxWidth = 1;
  const boxHeight = 1;
  const boxDepth = 1;
  const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
  // 중심이 아닌 양의 z축 방향으로 커지게끔 만듭니다.
  geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0, 0.5));

  // 아래 헬퍼 Object3D는 육면체들의 위치 변화를 간단하게 만들어줍니다.
  // lonHelper를 Y축으로 돌려 경도(longitude)를 맞출 수 있습니다.
  const lonHelper = new THREE.Object3D();
  scene.add(lonHelper);
  // latHelper를 X축으로 돌려 위도(latitude)를 맞출 수 있습니다.
  const latHelper = new THREE.Object3D();
  lonHelper.add(latHelper);
  // positionHelper는 다른 요소의 기준축을 구체의 끝에 맞추는 역할을 합니다.
  const positionHelper = new THREE.Object3D();
  positionHelper.position.z = 1;
  latHelper.add(positionHelper);

  const lonFudge = Math.PI * .5;
  const latFudge = Math.PI * -0.135;
  data.forEach((row, latNdx) => {
    row.forEach((value, lonNdx) => {
      if (value === undefined) {
        return;
      }
      const amount = (value - min) / range;
      const material = new THREE.MeshBasicMaterial();
      const hue = THREE.MathUtils.lerp(0.7, 0.3, amount);
      const saturation = 1;
      const lightness = THREE.MathUtils.lerp(0.1, 1.0, amount);
      material.color.setHSL(hue, saturation, lightness);
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      // 헬퍼들을 특정 위도와 경도로 이동시킵니다.
      lonHelper.rotation.y = THREE.MathUtils.degToRad(lonNdx + file.xllcorner) + lonFudge;
      latHelper.rotation.x = THREE.MathUtils.degToRad(latNdx + file.yllcorner) + latFudge;

      // positionHelper의 위치를 해당 mesh의 위치로 지정합니다.
      positionHelper.updateWorldMatrix(true, false);
      mesh.applyMatrix4(positionHelper.matrixWorld);

      mesh.scale.set(0.005, 0.005, THREE.MathUtils.lerp(0.01, 0.5, amount));
    });
  });
}
const parseData = (text)=>{
  const data = [];
  const settings = {data};
  let max;
  let min;
  // split into lines
  text.split('\n').forEach((line) => {
    // split the line by whitespace
    const parts = line.trim().split(/\s+/);
    if (parts.length === 2) {
      // only 2 parts, must be a key/value pair
      settings[parts[0]] = parseFloat(parts[1]);
    } else if (parts.length > 2) {
      // more than 2 parts, must be data
      const values = parts.map((v) => {
        const value = parseFloat(v);
        if (value === settings.NODATA_value) {
          return undefined;
        }
        max = Math.max(max === undefined ? value : max, value);
        min = Math.min(min === undefined ? value : min, value);
        return value;
      });
      data.push(values);
    }
  });
  return Object.assign(settings, {min, max});
}

const drawData = (file)=>{
  const {min, max, ncols, nrows, data} = file;
  const range = max - min;
  const ctx = document.querySelector('canvas').getContext('2d');
  // make the canvas the same size as the data
  ctx.canvas.width = ncols;
  ctx.canvas.height = nrows;
  // but display it double size so it's not too small
  ctx.canvas.style.width = px(ncols * 2);
  // fill the canvas to dark gray
  ctx.fillStyle = '#444';
  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  // draw each data point
  data.forEach((row, latNdx) => {
    row.forEach((value, lonNdx) => {
      if (value === undefined) {
        return;
      }
      const amount = (value - min) / range;
      const hue = 1;
      const saturation = 1;
      const lightness = amount;
      ctx.fillStyle = hsl(hue, saturation, lightness);
      ctx.fillRect(lonNdx, latNdx, 1, 1);
      });
    });
  }

  function px(v) {
    return `${v | 0}px`;
  }

  function hsl(h, s, l) {
    return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`;
  }

  
  // server -> ./resouce/gpw_v4.asc

  const loader = new THREE.TextureLoader();
  const texture = loader.load('resource/world.jpg', renderer);
  const geometry = new THREE.SphereGeometry(1, 64, 32);
  const material = new THREE.MeshBasicMaterial({ map: texture });
  scene.add(new THREE.Mesh(geometry, material));

  function render(time) {
    time *= 0.001;  // convert time to seconds
    
    if(resizeRendererToDisplaySize(renderer)){
      const canvas = renderer.domElement;
      camera.aspect  = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix(); 
    }

    renderer.render(scene, camera);
    /* requestAnimationFrame 함수에 업데이트*/
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
    console.log('load');
    loadFile('https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc')
    .then(parseData)
    .then(drawData);

 
  
}
window.addEventListener('load',main);
  </script>

</html>